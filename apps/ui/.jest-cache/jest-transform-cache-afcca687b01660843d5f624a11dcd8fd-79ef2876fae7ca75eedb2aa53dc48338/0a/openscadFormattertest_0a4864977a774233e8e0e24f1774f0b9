102ad8705d071920f25a318f63f8381c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const openscadFormatter_1 = require("../openscadFormatter");
describe('formatOpenScadCode', () => {
    it('preserves compact angle brackets in use/include statements', () => {
        const input = `// Import the library (modules/functions only; no top-level geometry executed)
use <lib/holes.scad>
use <lib/line.scad>
use <lib/spacing_utils.scad>`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`// Import the library (modules/functions only; no top-level geometry executed)
use <lib/holes.scad>
use <lib/line.scad>
use <lib/spacing_utils.scad>
`);
    });
    it('normalizes spacing for conditional blocks while preserving comments', () => {
        const input = `module example(){// leading comment
if(true){// first branch
cube(1);
}else if(false){/* keep block */cube(2);
}else{
// final branch
cube(3);
}
}`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`module example() {// leading comment
    if (true) {// first branch
        cube(1);
    } else if (false) {/* keep block */cube(2);
    } else {
        // final branch
        cube(3);
    }
}
`);
    });
    it('trims excessive blank lines and ensures a trailing newline', () => {
        const input = `cube(1);



sphere(2);`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`cube(1);

sphere(2);
`);
    });
    it('formats comparison and assignment operators without splitting multi-character tokens', () => {
        const input = `module metrics(){
if(total<=limit){
value+=1;
}else if(total>=limit){
value-=2;
}
if(value!=baseline){
return value==baseline;
}
}`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`module metrics() {
    if (total <= limit) {
        value += 1;
    } else if (total >= limit) {
        value -= 2;
    }
    if (value != baseline) {
        return value == baseline;
    }
}
`);
    });
    it('indents nested control flow and loops inside modules', () => {
        const input = `module tree(levels){
for(level=[0:levels-1]){
if(level==0){
cube([1,1,1]);
}else{
translate([0,0,level]){
rotate([0,0,45]){
cylinder(h=level+1,r=level/2);
}
}
}
}
}`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`module tree(levels) {
    for (level = [0:levels - 1]) {
        if (level == 0) {
            cube([1, 1, 1]);
        } else {
            translate([0, 0, level]) {
                rotate([0, 0, 45]) {
                    cylinder(h = level + 1, r = level / 2);
                }
            }
        }
    }
}
`);
    });
    it('does not treat import-like content inside strings or comments as actual imports', () => {
        const input = `// Example mentioning use <fake.scad> should stay intact
echo("use <fake.scad> inside string");
/* include <fake.scad> */
module noop(){
return;
}`;
        const result = (0, openscadFormatter_1.formatOpenScadCode)(input);
        expect(result).toBe(`// Example mentioning use <fake.scad> should stay intact
echo("use <fake.scad> inside string");
/* include <fake.scad> */
module noop() {
    return;
}
`);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3phY2hhcnltYXJpb24vc3JjL29wZW5zY2FkLXRhdXJpL2FwcHMvdWkvc3JjL3V0aWxzL19fdGVzdHNfXy9vcGVuc2NhZEZvcm1hdHRlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsNERBQTBEO0FBRTFELFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUU7SUFDbEMsRUFBRSxDQUFDLDREQUE0RCxFQUFFLEdBQUcsRUFBRTtRQUNwRSxNQUFNLEtBQUssR0FBRzs7OzZCQUdXLENBQUM7UUFFMUIsTUFBTSxNQUFNLEdBQUcsSUFBQSxzQ0FBa0IsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUV6QyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDOzs7O0NBSXZCLENBQUMsQ0FBQztJQUNELENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLHFFQUFxRSxFQUFFLEdBQUcsRUFBRTtRQUM3RSxNQUFNLEtBQUssR0FBRzs7Ozs7Ozs7RUFRaEIsQ0FBQztRQUVDLE1BQU0sTUFBTSxHQUFHLElBQUEsc0NBQWtCLEVBQUMsS0FBSyxDQUFDLENBQUM7UUFFekMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQzs7Ozs7Ozs7O0NBU3ZCLENBQUMsQ0FBQztJQUNELENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLDREQUE0RCxFQUFFLEdBQUcsRUFBRTtRQUNwRSxNQUFNLEtBQUssR0FBRzs7OztXQUlQLENBQUM7UUFFUixNQUFNLE1BQU0sR0FBRyxJQUFBLHNDQUFrQixFQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXpDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7OztDQUd2QixDQUFDLENBQUM7SUFDRCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyxzRkFBc0YsRUFBRSxHQUFHLEVBQUU7UUFDOUYsTUFBTSxLQUFLLEdBQUc7Ozs7Ozs7OztFQVNoQixDQUFDO1FBRUMsTUFBTSxNQUFNLEdBQUcsSUFBQSxzQ0FBa0IsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUV6QyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDOzs7Ozs7Ozs7O0NBVXZCLENBQUMsQ0FBQztJQUNELENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLHNEQUFzRCxFQUFFLEdBQUcsRUFBRTtRQUM5RCxNQUFNLEtBQUssR0FBRzs7Ozs7Ozs7Ozs7O0VBWWhCLENBQUM7UUFFQyxNQUFNLE1BQU0sR0FBRyxJQUFBLHNDQUFrQixFQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXpDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Q0FhdkIsQ0FBQyxDQUFDO0lBQ0QsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsaUZBQWlGLEVBQUUsR0FBRyxFQUFFO1FBQ3pGLE1BQU0sS0FBSyxHQUFHOzs7OztFQUtoQixDQUFDO1FBRUMsTUFBTSxNQUFNLEdBQUcsSUFBQSxzQ0FBa0IsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUV6QyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDOzs7Ozs7Q0FNdkIsQ0FBQyxDQUFDO0lBQ0QsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvemFjaGFyeW1hcmlvbi9zcmMvb3BlbnNjYWQtdGF1cmkvYXBwcy91aS9zcmMvdXRpbHMvX190ZXN0c19fL29wZW5zY2FkRm9ybWF0dGVyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T3BlblNjYWRDb2RlIH0gZnJvbSAnLi4vb3BlbnNjYWRGb3JtYXR0ZXInO1xuXG5kZXNjcmliZSgnZm9ybWF0T3BlblNjYWRDb2RlJywgKCkgPT4ge1xuICBpdCgncHJlc2VydmVzIGNvbXBhY3QgYW5nbGUgYnJhY2tldHMgaW4gdXNlL2luY2x1ZGUgc3RhdGVtZW50cycsICgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGAvLyBJbXBvcnQgdGhlIGxpYnJhcnkgKG1vZHVsZXMvZnVuY3Rpb25zIG9ubHk7IG5vIHRvcC1sZXZlbCBnZW9tZXRyeSBleGVjdXRlZClcbnVzZSA8bGliL2hvbGVzLnNjYWQ+XG51c2UgPGxpYi9saW5lLnNjYWQ+XG51c2UgPGxpYi9zcGFjaW5nX3V0aWxzLnNjYWQ+YDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdE9wZW5TY2FkQ29kZShpbnB1dCk7XG5cbiAgICBleHBlY3QocmVzdWx0KS50b0JlKGAvLyBJbXBvcnQgdGhlIGxpYnJhcnkgKG1vZHVsZXMvZnVuY3Rpb25zIG9ubHk7IG5vIHRvcC1sZXZlbCBnZW9tZXRyeSBleGVjdXRlZClcbnVzZSA8bGliL2hvbGVzLnNjYWQ+XG51c2UgPGxpYi9saW5lLnNjYWQ+XG51c2UgPGxpYi9zcGFjaW5nX3V0aWxzLnNjYWQ+XG5gKTtcbiAgfSk7XG5cbiAgaXQoJ25vcm1hbGl6ZXMgc3BhY2luZyBmb3IgY29uZGl0aW9uYWwgYmxvY2tzIHdoaWxlIHByZXNlcnZpbmcgY29tbWVudHMnLCAoKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBgbW9kdWxlIGV4YW1wbGUoKXsvLyBsZWFkaW5nIGNvbW1lbnRcbmlmKHRydWUpey8vIGZpcnN0IGJyYW5jaFxuY3ViZSgxKTtcbn1lbHNlIGlmKGZhbHNlKXsvKiBrZWVwIGJsb2NrICovY3ViZSgyKTtcbn1lbHNle1xuLy8gZmluYWwgYnJhbmNoXG5jdWJlKDMpO1xufVxufWA7XG5cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRPcGVuU2NhZENvZGUoaW5wdXQpO1xuXG4gICAgZXhwZWN0KHJlc3VsdCkudG9CZShgbW9kdWxlIGV4YW1wbGUoKSB7Ly8gbGVhZGluZyBjb21tZW50XG4gICAgaWYgKHRydWUpIHsvLyBmaXJzdCBicmFuY2hcbiAgICAgICAgY3ViZSgxKTtcbiAgICB9IGVsc2UgaWYgKGZhbHNlKSB7Lyoga2VlcCBibG9jayAqL2N1YmUoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmluYWwgYnJhbmNoXG4gICAgICAgIGN1YmUoMyk7XG4gICAgfVxufVxuYCk7XG4gIH0pO1xuXG4gIGl0KCd0cmltcyBleGNlc3NpdmUgYmxhbmsgbGluZXMgYW5kIGVuc3VyZXMgYSB0cmFpbGluZyBuZXdsaW5lJywgKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gYGN1YmUoMSk7XG5cblxuXG5zcGhlcmUoMik7YDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdE9wZW5TY2FkQ29kZShpbnB1dCk7XG5cbiAgICBleHBlY3QocmVzdWx0KS50b0JlKGBjdWJlKDEpO1xuXG5zcGhlcmUoMik7XG5gKTtcbiAgfSk7XG5cbiAgaXQoJ2Zvcm1hdHMgY29tcGFyaXNvbiBhbmQgYXNzaWdubWVudCBvcGVyYXRvcnMgd2l0aG91dCBzcGxpdHRpbmcgbXVsdGktY2hhcmFjdGVyIHRva2VucycsICgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGBtb2R1bGUgbWV0cmljcygpe1xuaWYodG90YWw8PWxpbWl0KXtcbnZhbHVlKz0xO1xufWVsc2UgaWYodG90YWw+PWxpbWl0KXtcbnZhbHVlLT0yO1xufVxuaWYodmFsdWUhPWJhc2VsaW5lKXtcbnJldHVybiB2YWx1ZT09YmFzZWxpbmU7XG59XG59YDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdE9wZW5TY2FkQ29kZShpbnB1dCk7XG5cbiAgICBleHBlY3QocmVzdWx0KS50b0JlKGBtb2R1bGUgbWV0cmljcygpIHtcbiAgICBpZiAodG90YWwgPD0gbGltaXQpIHtcbiAgICAgICAgdmFsdWUgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRvdGFsID49IGxpbWl0KSB7XG4gICAgICAgIHZhbHVlIC09IDI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBiYXNlbGluZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gYmFzZWxpbmU7XG4gICAgfVxufVxuYCk7XG4gIH0pO1xuXG4gIGl0KCdpbmRlbnRzIG5lc3RlZCBjb250cm9sIGZsb3cgYW5kIGxvb3BzIGluc2lkZSBtb2R1bGVzJywgKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gYG1vZHVsZSB0cmVlKGxldmVscyl7XG5mb3IobGV2ZWw9WzA6bGV2ZWxzLTFdKXtcbmlmKGxldmVsPT0wKXtcbmN1YmUoWzEsMSwxXSk7XG59ZWxzZXtcbnRyYW5zbGF0ZShbMCwwLGxldmVsXSl7XG5yb3RhdGUoWzAsMCw0NV0pe1xuY3lsaW5kZXIoaD1sZXZlbCsxLHI9bGV2ZWwvMik7XG59XG59XG59XG59XG59YDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdE9wZW5TY2FkQ29kZShpbnB1dCk7XG5cbiAgICBleHBlY3QocmVzdWx0KS50b0JlKGBtb2R1bGUgdHJlZShsZXZlbHMpIHtcbiAgICBmb3IgKGxldmVsID0gWzA6bGV2ZWxzIC0gMV0pIHtcbiAgICAgICAgaWYgKGxldmVsID09IDApIHtcbiAgICAgICAgICAgIGN1YmUoWzEsIDEsIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZShbMCwgMCwgbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgcm90YXRlKFswLCAwLCA0NV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3lsaW5kZXIoaCA9IGxldmVsICsgMSwgciA9IGxldmVsIC8gMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYCk7XG4gIH0pO1xuXG4gIGl0KCdkb2VzIG5vdCB0cmVhdCBpbXBvcnQtbGlrZSBjb250ZW50IGluc2lkZSBzdHJpbmdzIG9yIGNvbW1lbnRzIGFzIGFjdHVhbCBpbXBvcnRzJywgKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gYC8vIEV4YW1wbGUgbWVudGlvbmluZyB1c2UgPGZha2Uuc2NhZD4gc2hvdWxkIHN0YXkgaW50YWN0XG5lY2hvKFwidXNlIDxmYWtlLnNjYWQ+IGluc2lkZSBzdHJpbmdcIik7XG4vKiBpbmNsdWRlIDxmYWtlLnNjYWQ+ICovXG5tb2R1bGUgbm9vcCgpe1xucmV0dXJuO1xufWA7XG5cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRPcGVuU2NhZENvZGUoaW5wdXQpO1xuXG4gICAgZXhwZWN0KHJlc3VsdCkudG9CZShgLy8gRXhhbXBsZSBtZW50aW9uaW5nIHVzZSA8ZmFrZS5zY2FkPiBzaG91bGQgc3RheSBpbnRhY3RcbmVjaG8oXCJ1c2UgPGZha2Uuc2NhZD4gaW5zaWRlIHN0cmluZ1wiKTtcbi8qIGluY2x1ZGUgPGZha2Uuc2NhZD4gKi9cbm1vZHVsZSBub29wKCkge1xuICAgIHJldHVybjtcbn1cbmApO1xuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9