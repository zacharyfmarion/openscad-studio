bd3ef25d3d717207c9722160166616d8
"use strict";
/**
 * OpenSCAD Code Formatter
 *
 * Tree-sitter based formatter for OpenSCAD code
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.initParser = void 0;
exports.initFormatter = initFormatter;
exports.formatOpenScadCode = formatOpenScadCode;
const parser_1 = require("./parser");
const printer_1 = require("./printer");
const DEFAULT_OPTIONS = {
    indentSize: 4,
    useTabs: false,
    printWidth: 80,
};
let isInitialized = false;
/**
 * Initialize the formatter (must be called once before formatting)
 */
async function initFormatter() {
    if (isInitialized) {
        return;
    }
    await (0, parser_1.initParser)();
    isInitialized = true;
}
/**
 * Format OpenSCAD code
 */
async function formatOpenScadCode(code, options = {}) {
    // Ensure formatter is initialized
    if (!isInitialized) {
        await initFormatter();
    }
    // Parse the code
    const tree = (0, parser_1.parse)(code);
    if (!tree) {
        console.warn('[OpenSCAD Formatter] Failed to parse code, returning original');
        return code;
    }
    try {
        // Merge options with defaults
        const opts = { ...DEFAULT_OPTIONS, ...options };
        // Print the formatted code
        const formatted = (0, printer_1.printTree)(tree, opts);
        return formatted;
    }
    catch (error) {
        console.error('[OpenSCAD Formatter] Formatting error:', error);
        return code; // Return original code on error
    }
    finally {
        // Clean up the tree
        tree.delete();
    }
}
// Re-export types and utilities
var parser_2 = require("./parser");
Object.defineProperty(exports, "initParser", { enumerable: true, get: function () { return parser_2.initParser; } });
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parser_2.parse; } });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3phY2hhcnltYXJpb24vc3JjL29wZW5zY2FkLXRhdXJpL2FwcHMvdWkvc3JjL3V0aWxzL2Zvcm1hdHRlci9pbmRleC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7R0FJRzs7O0FBc0JILHNDQU9DO0FBS0QsZ0RBK0JDO0FBL0RELHFDQUE2QztBQUM3Qyx1Q0FBc0M7QUFRdEMsTUFBTSxlQUFlLEdBQTRCO0lBQy9DLFVBQVUsRUFBRSxDQUFDO0lBQ2IsT0FBTyxFQUFFLEtBQUs7SUFDZCxVQUFVLEVBQUUsRUFBRTtDQUNmLENBQUM7QUFFRixJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFFMUI7O0dBRUc7QUFDSSxLQUFLLFVBQVUsYUFBYTtJQUNqQyxJQUFJLGFBQWEsRUFBRSxDQUFDO1FBQ2xCLE9BQU87SUFDVCxDQUFDO0lBRUQsTUFBTSxJQUFBLG1CQUFVLEdBQUUsQ0FBQztJQUNuQixhQUFhLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLENBQUM7QUFFRDs7R0FFRztBQUNJLEtBQUssVUFBVSxrQkFBa0IsQ0FDdEMsSUFBWSxFQUNaLFVBQXlCLEVBQUU7SUFFM0Isa0NBQWtDO0lBQ2xDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNuQixNQUFNLGFBQWEsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxpQkFBaUI7SUFDakIsTUFBTSxJQUFJLEdBQUcsSUFBQSxjQUFLLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDekIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQywrREFBK0QsQ0FBQyxDQUFDO1FBQzlFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELElBQUksQ0FBQztRQUNILDhCQUE4QjtRQUM5QixNQUFNLElBQUksR0FBRyxFQUFFLEdBQUcsZUFBZSxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUM7UUFFaEQsMkJBQTJCO1FBQzNCLE1BQU0sU0FBUyxHQUFHLElBQUEsbUJBQVMsRUFBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFeEMsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQy9ELE9BQU8sSUFBSSxDQUFDLENBQUMsZ0NBQWdDO0lBQy9DLENBQUM7WUFBUyxDQUFDO1FBQ1Qsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNoQixDQUFDO0FBQ0gsQ0FBQztBQUVELGdDQUFnQztBQUNoQyxtQ0FBNkM7QUFBcEMsb0dBQUEsVUFBVSxPQUFBO0FBQUUsK0ZBQUEsS0FBSyxPQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy96YWNoYXJ5bWFyaW9uL3NyYy9vcGVuc2NhZC10YXVyaS9hcHBzL3VpL3NyYy91dGlscy9mb3JtYXR0ZXIvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcGVuU0NBRCBDb2RlIEZvcm1hdHRlclxuICpcbiAqIFRyZWUtc2l0dGVyIGJhc2VkIGZvcm1hdHRlciBmb3IgT3BlblNDQUQgY29kZVxuICovXG5cbmltcG9ydCB7IGluaXRQYXJzZXIsIHBhcnNlIH0gZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHsgcHJpbnRUcmVlIH0gZnJvbSAnLi9wcmludGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRPcHRpb25zIHtcbiAgaW5kZW50U2l6ZT86IG51bWJlcjtcbiAgdXNlVGFicz86IGJvb2xlYW47XG4gIHByaW50V2lkdGg/OiBudW1iZXI7XG59XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogUmVxdWlyZWQ8Rm9ybWF0T3B0aW9ucz4gPSB7XG4gIGluZGVudFNpemU6IDQsXG4gIHVzZVRhYnM6IGZhbHNlLFxuICBwcmludFdpZHRoOiA4MCxcbn07XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZm9ybWF0dGVyIChtdXN0IGJlIGNhbGxlZCBvbmNlIGJlZm9yZSBmb3JtYXR0aW5nKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdEZvcm1hdHRlcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKGlzSW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhd2FpdCBpbml0UGFyc2VyKCk7XG4gIGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEZvcm1hdCBPcGVuU0NBRCBjb2RlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmb3JtYXRPcGVuU2NhZENvZGUoXG4gIGNvZGU6IHN0cmluZyxcbiAgb3B0aW9uczogRm9ybWF0T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBFbnN1cmUgZm9ybWF0dGVyIGlzIGluaXRpYWxpemVkXG4gIGlmICghaXNJbml0aWFsaXplZCkge1xuICAgIGF3YWl0IGluaXRGb3JtYXR0ZXIoKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBjb2RlXG4gIGNvbnN0IHRyZWUgPSBwYXJzZShjb2RlKTtcbiAgaWYgKCF0cmVlKSB7XG4gICAgY29uc29sZS53YXJuKCdbT3BlblNDQUQgRm9ybWF0dGVyXSBGYWlsZWQgdG8gcGFyc2UgY29kZSwgcmV0dXJuaW5nIG9yaWdpbmFsJyk7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIE1lcmdlIG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gUHJpbnQgdGhlIGZvcm1hdHRlZCBjb2RlXG4gICAgY29uc3QgZm9ybWF0dGVkID0gcHJpbnRUcmVlKHRyZWUsIG9wdHMpO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbT3BlblNDQUQgRm9ybWF0dGVyXSBGb3JtYXR0aW5nIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gY29kZTsgLy8gUmV0dXJuIG9yaWdpbmFsIGNvZGUgb24gZXJyb3JcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBDbGVhbiB1cCB0aGUgdHJlZVxuICAgIHRyZWUuZGVsZXRlKCk7XG4gIH1cbn1cblxuLy8gUmUtZXhwb3J0IHR5cGVzIGFuZCB1dGlsaXRpZXNcbmV4cG9ydCB7IGluaXRQYXJzZXIsIHBhcnNlIH0gZnJvbSAnLi9wYXJzZXInO1xuZXhwb3J0IHR5cGUgeyBQYXJzZXIgfSBmcm9tICd3ZWItdHJlZS1zaXR0ZXInO1xuIl0sInZlcnNpb24iOjN9