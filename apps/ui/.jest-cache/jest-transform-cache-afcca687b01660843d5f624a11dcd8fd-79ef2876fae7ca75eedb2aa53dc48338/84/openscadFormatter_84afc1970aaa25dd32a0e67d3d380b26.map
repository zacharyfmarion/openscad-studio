{"file":"/Users/zacharymarion/src/openscad-tauri/apps/ui/src/utils/openscadFormatter.ts","mappings":"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","names":[],"sources":["/Users/zacharymarion/src/openscad-tauri/apps/ui/src/utils/openscadFormatter.ts"],"sourcesContent":["/**\n * OpenSCAD Code Formatter\n *\n * Provides basic formatting for OpenSCAD code:\n * - Consistent indentation\n * - Spacing around operators\n * - Bracket alignment\n * - Removes trailing whitespace\n * - Removes excessive blank lines\n */\n\nexport interface FormatOptions {\n  indentSize?: number;\n  useTabs?: boolean;\n}\n\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\n  indentSize: 4,\n  useTabs: false,\n};\n\nexport function formatOpenScadCode(code: string, options: FormatOptions = {}): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const indentStr = opts.useTabs ? '\\t' : ' '.repeat(opts.indentSize);\n\n  // Split into lines and remove trailing whitespace\n  const lines = code.split('\\n').map(line => line.trimEnd());\n\n  const formatted: string[] = [];\n  let indentLevel = 0;\n  let lastLineWasBlank = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const trimmed = line.trim();\n\n    // Skip multiple consecutive blank lines\n    if (trimmed === '') {\n      if (!lastLineWasBlank) {\n        formatted.push('');\n        lastLineWasBlank = true;\n      }\n      continue;\n    }\n\n    lastLineWasBlank = false;\n\n    // Count opening and closing braces to determine indent\n    let openBraces = 0;\n    let closeBraces = 0;\n    let inString = false;\n    let inLineComment = false;\n    let inBlockComment = false;\n\n    // First pass: count braces (ignore those in strings/comments)\n    for (let j = 0; j < trimmed.length; j++) {\n      const char = trimmed[j];\n      const nextChar = trimmed[j + 1];\n      const prevChar = trimmed[j - 1];\n\n      // String handling\n      if (char === '\"' && prevChar !== '\\\\') {\n        inString = !inString;\n        continue;\n      }\n      if (inString) continue;\n\n      // Line comment\n      if (char === '/' && nextChar === '/' && !inBlockComment) {\n        inLineComment = true;\n        break; // Rest of line is comment\n      }\n\n      // Block comment\n      if (char === '/' && nextChar === '*' && !inLineComment) {\n        inBlockComment = true;\n        j++; // Skip next char\n        continue;\n      }\n      if (char === '*' && nextChar === '/' && inBlockComment) {\n        inBlockComment = false;\n        j++; // Skip next char\n        continue;\n      }\n      if (inBlockComment) continue;\n\n      // Count braces\n      if (char === '{') openBraces++;\n      if (char === '}') closeBraces++;\n    }\n\n    // Determine indent for this line\n    // If line starts with }, decrease indent before\n    let lineIndent = indentLevel;\n    if (trimmed.startsWith('}')) {\n      lineIndent = Math.max(0, indentLevel - 1);\n    }\n\n    // Format the line content (add spacing, etc.)\n    const formattedContent = formatLineContent(trimmed);\n\n    // Add the formatted line with proper indentation\n    formatted.push(indentStr.repeat(lineIndent) + formattedContent);\n\n    // Update indent level for next line\n    // Closing braces decrease level\n    indentLevel = Math.max(0, indentLevel - closeBraces);\n    // Opening braces increase level\n    indentLevel += openBraces;\n  }\n\n  // Remove trailing blank lines and ensure single newline at end\n  while (formatted.length > 0 && formatted[formatted.length - 1].trim() === '') {\n    formatted.pop();\n  }\n\n  return formatted.join('\\n') + '\\n';\n}\n\n/**\n * Format the content of a single line (spacing around operators, etc.)\n */\nconst MULTI_CHAR_OPERATORS = ['<=', '>=', '==', '!=', '+=', '-=', '*=', '/=', '%='];\n\nfunction formatLineContent(line: string): string {\n  let result = '';\n  let inString = false;\n  let commentMode: 'line' | 'block' | null = null;\n  let inImportPath = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    const nextChar = line[i + 1];\n    const prevChar = line[i - 1];\n    const prevResultChar = result[result.length - 1];\n\n    // Handle strings\n    if (char === '\"' && prevChar !== '\\\\') {\n      inString = !inString;\n      result += char;\n      continue;\n    }\n    if (inString) {\n      result += char;\n      continue;\n    }\n\n    // Handle comments\n    if (commentMode === 'line') {\n      result += char;\n      continue;\n    }\n\n    if (commentMode === 'block') {\n      result += char;\n      if (char === '*' && nextChar === '/') {\n        result += nextChar;\n        i++;\n        commentMode = null;\n      }\n      continue;\n    }\n\n    if (char === '/' && nextChar === '/') {\n      commentMode = 'line';\n      result += char;\n      continue;\n    }\n\n    if (char === '/' && nextChar === '*') {\n      commentMode = 'block';\n      result += char;\n      continue;\n    }\n\n    if (!inImportPath && char === '<') {\n      const trimmedResult = result.trimEnd();\n      if (/\\b(?:use|include)$/.test(trimmedResult)) {\n        if (!result.endsWith(' ')) {\n          result += ' ';\n        }\n        inImportPath = true;\n        result += char;\n        continue;\n      }\n    }\n\n    if (inImportPath) {\n      result += char;\n      if (char === '>') {\n        inImportPath = false;\n      }\n      continue;\n    }\n\n    if (!inImportPath) {\n      const twoChar = line.slice(i, i + 2);\n      if (MULTI_CHAR_OPERATORS.includes(twoChar)) {\n        const prevResultChar = result[result.length - 1];\n        if (prevResultChar && prevResultChar !== ' ' && prevResultChar !== '(') {\n          result += ' ';\n        }\n        result += twoChar;\n        const followingChar = line[i + 2];\n        if (followingChar && followingChar !== ' ' && followingChar !== ')' && followingChar !== ';' && followingChar !== ',') {\n          result += ' ';\n        }\n        i++;\n        continue;\n      }\n    }\n\n    // Add space after commas\n    if (char === ',') {\n      result += char;\n      if (nextChar && nextChar !== ' ' && nextChar !== '\\n') {\n        result += ' ';\n      }\n      continue;\n    }\n\n    // Add space around binary operators\n    const isBinaryOp = ['=', '+', '-', '*', '/', '%', '<', '>'].includes(char);\n    if (isBinaryOp) {\n      // Check if it's actually a binary operator (not part of something else)\n      const isActuallyBinary =\n        (char === '=' && nextChar !== '=') ||\n        (char === '!' && nextChar === '=') ||\n        (char === '<' || char === '>') ||\n        (['+', '-', '*', '/', '%'].includes(char));\n\n      if (isActuallyBinary) {\n        // Add space before if needed\n        if (prevResultChar && prevResultChar !== ' ' && prevResultChar !== '(') {\n          result += ' ';\n        }\n        result += char;\n        // Add space after if needed\n        if (nextChar && nextChar !== ' ') {\n          result += ' ';\n        }\n        continue;\n      }\n    }\n\n    // Default: just add the character\n    result += char;\n  }\n\n  const singleLineCommentIndex = result.indexOf('//');\n  const blockCommentIndex = result.indexOf('/*');\n  const commentIndexes = [singleLineCommentIndex, blockCommentIndex].filter(index => index >= 0);\n  const prefixEnd = commentIndexes.length > 0 ? Math.min(...commentIndexes) : result.length;\n  const prefix = result.slice(0, prefixEnd);\n  const suffix = result.slice(prefixEnd);\n\n  const normalizedPrefix = prefix\n    .replace(/}\\s*else/g, '} else')\n    .replace(/else\\s*if/g, 'else if')\n    .replace(/else\\s*\\{/g, 'else {')\n    .replace(/\\bif\\s*\\(/g, 'if (')\n    .replace(/\\bfor\\s*\\(/g, 'for (')\n    .replace(/\\bwhile\\s*\\(/g, 'while (')\n    .replace(/\\)\\s*\\{/g, ') {')\n    .replace(/else if\\s*\\(([^)]*)\\)\\s*\\{/g, 'else if ($1) {')\n    .replace(/\\b(if|for|while)\\s*\\(([^)]*)\\)\\s*\\{/g, (_match, keyword, condition) => `${keyword} (${condition}) {`)\n    .replace(/^(use|include)\\s*<\\s*([^>]+?)\\s*>/g, '$1 <$2>');\n\n  return normalizedPrefix + suffix;\n}\n"],"version":3}