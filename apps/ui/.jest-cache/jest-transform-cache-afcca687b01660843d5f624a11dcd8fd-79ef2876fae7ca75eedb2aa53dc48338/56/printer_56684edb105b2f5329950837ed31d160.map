{"file":"/Users/zacharymarion/src/openscad-tauri/apps/ui/src/utils/formatter/printer.ts","mappings":"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","names":[],"sources":["/Users/zacharymarion/src/openscad-tauri/apps/ui/src/utils/formatter/printer.ts"],"sourcesContent":["/**\n * Tree-sitter based printer for OpenSCAD\n *\n * Converts AST to formatted code using the Doc IR\n */\n\nimport type * as TreeSitter from 'web-tree-sitter';\nimport type { FormatOptions } from './index';\nimport { concat, hardline, indent, line, group, join } from './doc';\nimport type { Doc } from './doc';\n\n/**\n * Print a tree-sitter syntax tree as formatted code\n */\nexport function printTree(tree: TreeSitter.Tree, options: Required<FormatOptions>): string {\n  const doc = printNode(tree.rootNode, options);\n  return printDoc(doc, options);\n}\n\n/**\n * Print a single AST node\n */\nfunction printNode(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const { type, text } = node;\n\n  // Debug log for unhandled node types\n  if (!['source_file', 'module_declaration', 'function_declaration', 'block', 'union_block',\n        'if_statement', 'if_block', 'for_statement', 'for_block', 'assignment', 'binary_expression',\n        'unary_expression', 'call_expression', 'module_call', 'function_call',\n        'transform_chain', 'arguments', 'parameters_declaration', 'parameter', 'parenthesized_assignments',\n        'parenthesized_expression', 'ternary_expression', 'index_expression', 'dot_index_expression',\n        'list', 'vector', 'array', 'range',\n        'comment', 'identifier', 'number', 'decimal', 'integer', 'float', 'string', 'boolean',\n        'special_variable', 'use_statement', 'include_statement', 'include_path',\n        'assert_statement', 'assert_expression',\n        'modifier', 'modifier_chain', 'intersection_for', 'intersection_for_block',\n        'use', 'if', 'else', 'module',\n        '(', ')', '[', ']', '{', '}', ',', ';', '=', ':', 'for', 'whitespace', '\\n',\n        '$', '.', '#', '%', '?', '!'].includes(type)) {\n    console.log(`[Formatter] Unknown node type: \"${type}\", text: \"${text.substring(0, 50)}\"`);\n  }\n\n  // Handle different node types\n  switch (type) {\n    case 'source_file':\n      return printSourceFile(node, options);\n\n    case 'module_declaration':\n      return printModuleDeclaration(node, options);\n\n    case 'function_declaration':\n      return printFunctionDeclaration(node, options);\n\n    case 'block':\n    case 'union_block':\n      return printBlock(node, options);\n\n    case 'if_statement':\n    case 'if_block':\n      return printIfStatement(node, options);\n\n    case 'for_statement':\n    case 'for_block':\n      return printForStatement(node, options);\n\n    case 'intersection_for':\n    case 'intersection_for_block':\n      return printIntersectionFor(node, options);\n\n    case 'assignment':\n      return printAssignment(node, options);\n\n    case 'binary_expression':\n      return printBinaryExpression(node, options);\n\n    case 'unary_expression':\n      return printUnaryExpression(node, options);\n\n    case 'call_expression':\n    case 'module_call':\n    case 'function_call':\n      return printCallExpression(node, options);\n\n    case 'transform_chain':\n      return printTransformChain(node, options);\n\n    case 'arguments':\n      return printArguments(node, options);\n\n    case 'list':\n    case 'vector':\n    case 'array':\n      return printList(node, options);\n\n    case 'range':\n      return printRange(node, options);\n\n    case 'ternary_expression':\n      return printTernaryExpression(node, options);\n\n    case 'index_expression':\n      return printIndexExpression(node, options);\n\n    case 'dot_index_expression':\n      return printDotIndexExpression(node, options);\n\n    case 'parenthesized_expression':\n      return printParenthesizedExpression(node, options);\n\n    case 'use_statement':\n      return printUseStatement(node, options);\n\n    case 'assert_statement':\n    case 'assert_expression':\n      return printAssert(node, options);\n\n    case 'modifier_chain':\n      return printModifierChain(node, options);\n\n    case 'comment':\n      return text;\n\n    case 'parameter':\n    case 'identifier':\n    case 'number':\n    case 'decimal':\n    case 'integer':\n    case 'float':\n    case 'string':\n    case 'boolean':\n    case 'special_variable':\n      return text;\n\n    default:\n      // For unknown nodes, try to print children or fall back to text\n      if (node.childCount > 0) {\n        return printChildren(node, options);\n      }\n      return text;\n  }\n}\n\nfunction printSourceFile(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n  let lastWasComment = false;\n  let lastWasDeclaration = false;\n  let prevChild: TreeSitter.Node | null = null;\n\n  for (let i = 0; i < node.childCount; i++) {\n    const child = node.child(i);\n    if (!child) continue;\n\n    // Skip whitespace nodes and semicolons (we'll add them ourselves)\n    if (child.type === 'whitespace' || child.type === '\\n' || child.type === ';') {\n      continue;\n    }\n\n    const childDoc = printNode(child, options);\n\n    // Check if there was a blank line before this child in the original code\n    let blankLineBefore = false;\n    if (prevChild) {\n      const lineDiff = child.startPosition.row - prevChild.endPosition.row;\n      blankLineBefore = lineDiff > 1;\n    }\n\n    // Add blank line if there was one in the original\n    const isComment = child.type === 'comment';\n    if (blankLineBefore && i > 0) {\n      parts.push(hardline());\n    }\n\n    // Add blank line between top-level declarations (but not after comments)\n    const isDecl = isDeclaration(child.type);\n    if (i > 0 && isDecl && lastWasDeclaration && !blankLineBefore) {\n      parts.push(hardline());\n    }\n\n    parts.push(childDoc);\n\n    // Add semicolon for statements that need it\n    if (needsSemicolon(child.type, child)) {\n      parts.push(';');\n    }\n\n    parts.push(hardline());\n    lastWasComment = isComment;\n    lastWasDeclaration = isDecl;\n    prevChild = child;\n  }\n\n  return concat(parts);\n}\n\nfunction printModuleDeclaration(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['module', ' '];  // Always add space after 'module'\n\n  for (const child of node.children) {\n    if (!child) continue;\n\n    if (child.type === 'module') {\n      // Skip the 'module' keyword itself\n      continue;\n    } else if (child.type === 'identifier') {\n      parts.push(child.text);\n    } else if (child.type === 'parameters_declaration') {\n      parts.push(printParameters(child, options));\n    } else if (child.type === 'block' || child.type === 'union_block') {\n      parts.push(' ', printBlock(child, options));\n    } else if (child.type === 'whitespace' || child.type === '\\n' || child.type === ';') {\n      // Skip\n      continue;\n    } else {\n      // This handles module body without braces (transform chains, etc.)\n      parts.push(' ', printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printFunctionDeclaration(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['function'];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'identifier') {\n      parts.push(' ', child.text);\n    } else if (child.type === 'parameters_declaration') {\n      parts.push(printParameters(child, options));\n    } else if (child.type === '=') {\n      parts.push(' ', child.text, ' ');\n    } else if (child.type !== 'function') {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  parts.push(';');\n  return concat(parts);\n}\n\nfunction printParameters(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const params: Doc[] = [];\n  let firstParamLine = -1;\n  let lastParamLine = -1;\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '(' || child.type === ')' || child.type === ',') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n\n    // Track line positions to detect multiline parameters\n    if (firstParamLine === -1) {\n      firstParamLine = child.startPosition.row;\n    }\n    lastParamLine = child.endPosition.row;\n\n    params.push(printNode(child, options));\n  }\n\n  if (params.length === 0) {\n    return '()';\n  }\n\n  // Check if parameters were originally multiline\n  const isMultiline = lastParamLine > firstParamLine;\n\n  if (isMultiline) {\n    // Format as multiline with Prettier-style formatting\n    const parts: Doc[] = [];\n\n    params.forEach((param, i) => {\n      parts.push(param);\n      if (i < params.length - 1) {\n        parts.push(',');\n        parts.push(hardline());\n      }\n    });\n\n    return concat([\n      '(',\n      indent(concat([hardline(), ...parts])),\n      hardline(),\n      ')',\n    ]);\n  }\n\n  // Keep single-line parameters compact\n  return concat([\n    '(',\n    join(', ', params),\n    ')',\n  ]);\n}\n\nfunction printBlock(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const items: Array<{ stmt: Doc; needsSemi: boolean; blankLineBefore: boolean; child: TreeSitter.Node }> = [];\n  let prevChild: TreeSitter.Node | null = null;\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '{' || child.type === '}' || child.type === ';') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n\n    const stmt = printNode(child, options);\n\n    // Determine if this statement needs a semicolon\n    let needsSemi = false;\n    if (child.type === 'assignment') {\n      needsSemi = true;\n    } else if (child.type === 'transform_chain') {\n      // Check if transform_chain ends with a block\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    } else if (child.type === 'modifier_chain') {\n      // Check if modifier_chain ends with a block\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    } else if (child.type === 'module_call' || child.type === 'call_expression') {\n      // Module/function calls without blocks need semicolons\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    } else if (child.type === 'module_declaration') {\n      // Module declarations without blocks need semicolons\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    } else if (child.type === 'if_statement' || child.type === 'if_block') {\n      // If statements - check if they need semicolons\n      // If they have else, printIfStatement handles semicolons\n      // Otherwise, need semicolons if no block\n      const hasElse = hasChildOfType(child, 'else');\n      if (!hasElse) {\n        const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n        needsSemi = !hasBlock;\n      }\n    } else if (child.type === 'for_statement' || child.type === 'for_block') {\n      // For statements without blocks need semicolons\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    } else if (child.type === 'intersection_for' || child.type === 'intersection_for_block') {\n      // Intersection_for without blocks need semicolons\n      const hasBlock = hasChildOfType(child, 'union_block') || hasChildOfType(child, 'block');\n      needsSemi = !hasBlock;\n    }\n\n    // Check if there was a blank line before this statement in the original code\n    let blankLineBefore = false;\n    if (prevChild) {\n      const lineDiff = child.startPosition.row - prevChild.endPosition.row;\n      blankLineBefore = lineDiff > 1;\n    }\n\n    items.push({ stmt, needsSemi, blankLineBefore, child });\n    prevChild = child;\n  }\n\n  if (items.length === 0) {\n    return '{}';\n  }\n\n  const statements: Doc[] = [];\n  items.forEach(({ stmt, needsSemi, blankLineBefore }, i) => {\n    // Add blank line if there was one in the original\n    if (blankLineBefore && i > 0) {\n      statements.push(hardline());\n    }\n\n    statements.push(stmt);\n    if (needsSemi) {\n      statements.push(';');\n    }\n\n    // Add hardline after each statement except the last\n    if (i < items.length - 1) {\n      statements.push(hardline());\n    }\n  });\n\n  return group(concat([\n    '{',\n    indent(concat([hardline(), ...statements])),\n    hardline(),\n    '}',\n  ]));\n}\n\nfunction printIfStatement(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['if'];\n  let hasElse = false;\n  let seenElse = false;\n  let conditionEndRow = -1;\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'if') {\n      continue;\n    } else if (child.type === 'condition' || child.type === 'parenthesized_expression') {\n      const conditionChild = child.children[1] || child;\n      if (conditionChild) {\n        parts.push(' (', printNode(conditionChild, options), ')');\n      }\n      conditionEndRow = child.endPosition.row;\n    } else if (child.type === 'block' || child.type === 'union_block') {\n      parts.push(' ', printNode(child, options));\n    } else if (child.type === 'else') {\n      // Add semicolon before else if we're not in a block\n      if (!hasChildOfType(node, 'union_block') && !hasChildOfType(node, 'block')) {\n        parts.push(';');\n      }\n      parts.push(' else');\n      hasElse = true;\n      seenElse = true;\n    } else if (child.type === 'whitespace' || child.type === '\\n' || child.type === ';') {\n      // Skip\n      continue;\n    } else {\n      // This handles any statement/expression in the if body (without braces)\n      // Check if body is on a new line\n      const isMultiline = conditionEndRow >= 0 && child.startPosition.row > conditionEndRow;\n\n      if (isMultiline && !seenElse) {\n        // Body on new line - add newline and indent\n        parts.push(indent(concat([hardline(), printNode(child, options)])));\n      } else {\n        // Body on same line\n        parts.push(' ', printNode(child, options));\n      }\n    }\n  }\n\n  // Add final semicolon if there's an else clause (and no block)\n  if (hasElse && !hasChildOfType(node, 'union_block') && !hasChildOfType(node, 'block')) {\n    parts.push(';');\n  }\n\n  return concat(parts);\n}\n\nfunction printForStatement(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['for', ' '];\n  let block: Doc | null = null;\n\n  for (const child of node.children) {\n    if (!child) continue;\n\n    if (child.type === 'for') {\n      // Skip the 'for' keyword itself\n      continue;\n    } else if (child.type === 'parenthesized_assignments') {\n      // Print the parenthesized assignments (e.g., \"(i = [0:10])\")\n      parts.push(printParenthesizedAssignments(child, options));\n    } else if (child.type === 'block' || child.type === 'union_block') {\n      block = printNode(child, options);\n    } else if (child.type !== ';' && child.type !== 'whitespace' && child.type !== '\\n') {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  if (block) {\n    parts.push(' ', block);\n  }\n\n  return concat(parts);\n}\n\nfunction printParenthesizedAssignments(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['('];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '(' || child.type === ')') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (child.type === '=') {\n      parts.push(' ', child.text, ' ');\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  parts.push(')');\n  return concat(parts);\n}\n\nfunction printAssignment(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (let i = 0; i < node.childCount; i++) {\n    const child = node.child(i);\n    if (!child) continue;\n\n    if (child.type === '=') {\n      parts.push(' ', child.text, ' ');\n    } else if (child.type === ';') {\n      // Skip semicolons - they'll be added by printSourceFile\n      continue;\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printTransformChain(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n  let hasBlock = false;\n\n  for (const child of node.children) {\n    if (!child) continue;\n\n    if (child.type === 'module_call' || child.type === 'function_call') {\n      parts.push(printCallExpression(child, options));\n    } else if (child.type === 'union_block' || child.type === 'block') {\n      parts.push(' ', printBlock(child, options));\n      hasBlock = true;\n    } else if (child.type === ';') {\n      // Skip - semicolon handled by parent based on whether there's a block\n      continue;\n    } else if (child.type === 'transform_chain') {\n      // Nested transform chain\n      parts.push(' ', printTransformChain(child, options));\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printBinaryExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (isOperator(child.text)) {\n      parts.push(' ', child.text, ' ');\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printUnaryExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const operator = node.child(0);\n  const operand = node.child(1);\n\n  if (!operator || !operand) {\n    return node.text;\n  }\n\n  // Handle negative numbers/expressions (no space for minus)\n  if (operator.text === '-') {\n    return concat([operator.text, printNode(operand, options)]);\n  }\n\n  // Other unary operators (like !)\n  return concat([operator.text, printNode(operand, options)]);\n}\n\nfunction printCallExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'identifier') {\n      parts.push(child.text);\n    } else if (child.type === 'arguments') {\n      parts.push(printArguments(child, options));\n    } else if (child.type !== ';' && child.type !== 'whitespace' && child.type !== '\\n') {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printArguments(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const args: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '(' || child.type === ')' || child.type === ',') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    args.push(printNode(child, options));\n  }\n\n  if (args.length === 0) {\n    return '()';\n  }\n\n  return concat([\n    '(',\n    join(concat([', ']), args),\n    ')',\n  ]);\n}\n\nfunction printList(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const items: Doc[] = [];\n  const children: TreeSitter.Node[] = [];\n  let firstItemLine = -1;\n  let lastItemLine = -1;\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '[' || child.type === ']' || child.type === ',') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n\n    // Track line positions to detect multiline arrays\n    if (firstItemLine === -1) {\n      firstItemLine = child.startPosition.row;\n    }\n    lastItemLine = child.endPosition.row;\n\n    children.push(child);\n    items.push(printNode(child, options));\n  }\n\n  if (items.length === 0) {\n    return '[]';\n  }\n\n  // Check if array was originally multiline\n  const isMultiline = lastItemLine > firstItemLine;\n\n  if (isMultiline && items.length > 0) {\n    // Format as multiline with Prettier-style formatting\n    // Each item on its own line with comma, closing bracket unindented\n    const parts: Doc[] = [];\n\n    items.forEach((item, i) => {\n      parts.push(item);\n      if (i < items.length - 1) {\n        parts.push(',');\n        parts.push(hardline());\n      }\n    });\n\n    return concat([\n      '[',\n      indent(concat([hardline(), ...parts])),\n      hardline(),\n      ']',\n    ]);\n  }\n\n  // Keep single-line arrays compact: [1, 2, 3] not [ 1, 2, 3 ]\n  return concat([\n    '[',\n    join(', ', items),\n    ']',\n  ]);\n}\n\nfunction printRange(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (child.type === ':') {\n      parts.push(child.text);\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printTernaryExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n  let firstChildLine = -1;\n  let lastChildLine = -1;\n\n  // Track line positions to detect multiline ternaries\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (firstChildLine === -1) {\n      firstChildLine = child.startPosition.row;\n    }\n    lastChildLine = child.endPosition.row;\n  }\n\n  const isMultiline = lastChildLine > firstChildLine;\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (child.type === '?') {\n      if (isMultiline) {\n        parts.push(hardline(), indent(concat([child.text, ' '])));\n      } else {\n        parts.push(' ', child.text, ' ');\n      }\n    } else if (child.type === ':') {\n      if (isMultiline) {\n        parts.push(hardline(), indent(concat([child.text, ' '])));\n      } else {\n        parts.push(' ', child.text, ' ');\n      }\n    } else {\n      // Regular child node - just add it, indentation handled by ? and : above\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printIndexExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    parts.push(printNode(child, options));\n  }\n\n  return concat(parts);\n}\n\nfunction printDotIndexExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    parts.push(printNode(child, options));\n  }\n\n  return concat(parts);\n}\n\nfunction printParenthesizedExpression(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['('];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === '(' || child.type === ')') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    parts.push(printNode(child, options));\n  }\n\n  parts.push(')');\n  return concat(parts);\n}\n\nfunction printUseStatement(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (child.type === 'use') {\n      parts.push(child.text, ' ');\n    } else if (child.type === 'include_path') {\n      parts.push(child.text);\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printAssert(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['assert'];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'assert') {\n      continue;\n    }\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    parts.push(printNode(child, options));\n  }\n\n  return concat(parts);\n}\n\nfunction printModifierChain(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (!child) continue;\n    if (child.type === 'whitespace' || child.type === '\\n') {\n      continue;\n    }\n    if (child.type === 'modifier') {\n      parts.push(child.text);\n    } else if (child.type === 'module_call' || child.type === 'function_call' || child.type === 'transform_chain') {\n      if (parts.length > 0) {\n        parts.push(' ');\n      }\n      parts.push(printNode(child, options));\n    } else {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  return concat(parts);\n}\n\nfunction printIntersectionFor(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = ['intersection_for', ' '];\n  let block: Doc | null = null;\n\n  for (const child of node.children) {\n    if (!child) continue;\n\n    if (child.type === 'intersection_for') {\n      continue;\n    } else if (child.type === 'parenthesized_assignments') {\n      parts.push(printParenthesizedAssignments(child, options));\n    } else if (child.type === 'block' || child.type === 'union_block') {\n      block = printNode(child, options);\n    } else if (child.type !== ';' && child.type !== 'whitespace' && child.type !== '\\n') {\n      parts.push(printNode(child, options));\n    }\n  }\n\n  if (block) {\n    parts.push(' ', block);\n  }\n\n  return concat(parts);\n}\n\nfunction printChildren(node: TreeSitter.Node, options: Required<FormatOptions>): Doc {\n  const parts: Doc[] = [];\n\n  for (let i = 0; i < node.childCount; i++) {\n    const child = node.child(i);\n    if (!child) continue;\n    parts.push(printNode(child, options));\n  }\n\n  return concat(parts);\n}\n\n// Helper functions\n\nfunction isDeclaration(type: string): boolean {\n  return type === 'module_declaration' || type === 'function_declaration';\n}\n\nfunction needsSemicolon(type: string, node?: TreeSitter.Node): boolean {\n  if (type === 'assignment') {\n    return true;\n  }\n  if (type === 'transform_chain' && node) {\n    // Only add semicolon if transform chain doesn't have a block\n    const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n    return !hasBlock;\n  }\n  if (type === 'modifier_chain' && node) {\n    // Modifier chains without blocks need semicolons (like #rotate(...) cylinder(...);)\n    const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n    return !hasBlock;\n  }\n  if (type === 'module_declaration' && node) {\n    // Module declarations without blocks need semicolons\n    const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n    return !hasBlock;\n  }\n  if (type === 'if_statement' || type === 'if_block') {\n    // If statements with else need semicolons handled in printIfStatement\n    // If statements without else and without blocks need semicolons\n    if (node) {\n      const hasElse = hasChildOfType(node, 'else');\n      if (hasElse) {\n        return false; // printIfStatement handles semicolons for if-else\n      }\n      const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n      return !hasBlock;\n    }\n    return false;\n  }\n  if (type === 'for_statement' || type === 'for_block') {\n    // For statements need semicolons if they don't have blocks\n    if (node) {\n      const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n      return !hasBlock;\n    }\n  }\n  if (type === 'intersection_for' || type === 'intersection_for_block') {\n    // Intersection_for statements need semicolons if they don't have blocks\n    if (node) {\n      const hasBlock = hasChildOfType(node, 'union_block') || hasChildOfType(node, 'block');\n      return !hasBlock;\n    }\n  }\n  return false;\n}\n\nfunction hasChildOfType(node: TreeSitter.Node, type: string): boolean {\n  for (const child of node.children) {\n    if (child && child.type === type) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isOperator(text: string): boolean {\n  return ['+', '-', '*', '/', '%', '==', '!=', '<', '>', '<=', '>=', '&&', '||', '!'].includes(text);\n}\n\n/**\n * Convert Doc IR to actual string output\n */\nfunction printDoc(doc: Doc, options: Required<FormatOptions>, mode: 'flat' | 'break' = 'break'): string {\n  const indentStr = options.useTabs ? '\\t' : ' '.repeat(options.indentSize);\n  let output = '';\n  let indentLevel = 0;\n\n  function print(d: Doc, m: 'flat' | 'break' = mode): void {\n    if (typeof d === 'string') {\n      output += d;\n      return;\n    }\n\n    if (Array.isArray(d)) {\n      for (const part of d) {\n        print(part, m);\n      }\n      return;\n    }\n\n    switch (d.type) {\n      case 'concat':\n        for (const part of d.parts) {\n          print(part, m);\n        }\n        break;\n\n      case 'line':\n        if (d.hard || m === 'break') {\n          output += '\\n' + indentStr.repeat(indentLevel);\n        } else if (!d.soft) {\n          output += ' ';\n        }\n        break;\n\n      case 'group':\n        print(d.contents, d.shouldBreak ? 'break' : 'flat');\n        break;\n\n      case 'indent':\n        indentLevel++;\n        print(d.contents, m);\n        indentLevel--;\n        break;\n\n      case 'if-break':\n        print(m === 'break' ? d.breakContents : d.flatContents, m);\n        break;\n\n      case 'fill':\n        for (const part of d.parts) {\n          print(part, m);\n        }\n        break;\n    }\n  }\n\n  print(doc);\n\n  // Remove trailing whitespace from each line and ensure single trailing newline\n  let result = output.split('\\n').map(line => line.trimEnd()).join('\\n');\n\n  // Ensure exactly one trailing newline (all text files should end with newline)\n  // Unless the result is empty\n  if (result.trim().length === 0) {\n    return '';\n  }\n  result = result.replace(/\\n*$/, '\\n');\n\n  return result;\n}\n"],"version":3}